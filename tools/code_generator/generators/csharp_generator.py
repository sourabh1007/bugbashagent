"""
Simplified C# Project Generator

Only creates minimal project structure, lets LLM generate actual implementation files.
No dummy test files are created automatically.
"""

import os
import re
from datetime import datetime
from typing import Dict, List, Any
from .base_generator import BaseProjectGenerator


class CSharpProjectGenerator(BaseProjectGenerator):
    """Simplified generator for C# projects - no automatic test file generation"""
    
    def __init__(self):
        super().__init__()
        self.language = 'csharp'
    
    @property
    def target_framework(self) -> str:
        """Get the target framework version from configuration"""
        dotnet_version = self.get_language_version('dotnet')
        return f"net{dotnet_version}"
    
    def generate_project(self, project_dir: str, product_name: str, scenarios: List[str], generated_content: str, analyzer_output: Dict[str, Any] = None) -> Dict[str, str]:
        """Generate minimal C# project structure - only create actual project files, not dummy tests"""
        created_files = {}
        
        # Sanitize project name for C# identifiers
        sanitized_name = self._sanitize_csharp_identifier(product_name)
        
        # Create essential project files for C#
        # 1. Create .csproj file (essential for building) - include CosmosDB if needed
        csproj_path = os.path.join(project_dir, f"{sanitized_name}.csproj")
        self._write_file(csproj_path, self._create_csproj_content(analyzer_output))
        created_files["project_file"] = csproj_path
        
        # 2. Create basic README file
        readme_path = os.path.join(project_dir, "README.md")
        self._write_file(readme_path, self._create_project_readme(sanitized_name, product_name, scenarios))
        created_files["readme"] = readme_path
        
        return created_files
    
    def _write_file(self, file_path: str, content: str) -> None:
        """Write content to file with proper encoding"""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _create_csproj_content(self, analyzer_output: Dict[str, Any] = None) -> str:
        """Create .csproj content with common packages and configured versions, including CosmosDB if needed"""
        packages = self.get_packages_for_language(self.language, analyzer_output)
        
        package_references = []
        for package_name, version in packages.items():
            package_references.append(f'    <PackageReference Include="{package_name}" Version="{version}" />')
        
        packages_xml = '\n'.join(package_references)
        
        return f"""<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>{self.target_framework}</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
{packages_xml}
  </ItemGroup>

</Project>"""
    
    def _create_project_readme(self, sanitized_name: str, product_name: str, scenarios: List[str]) -> str:
        """Create simple README for the project with test framework information"""
        dotnet_version = self.get_language_version('dotnet')
        test_framework = self.get_test_framework_for_language(self.language)
        
        return f"""# {product_name} - C# Application

This is a C# application for **{product_name}** using .NET {dotnet_version}.

## 📋 Functional Requirements

{self._format_scenarios_list(scenarios)}

## 🧪 Testing Framework

This project is configured to use **{test_framework.title()}** as the primary testing framework.

Test files should follow the naming convention:
- `*Test.cs` or `*Tests.cs` for test classes
- Test methods should be decorated with `[Test]` attribute
- Setup methods use `[SetUp]` and teardown methods use `[TearDown]`

## 🚀 Building and Running

This project will contain the complete implementation files generated by the LLM.

### Prerequisites
- .NET {dotnet_version} SDK or later
- Visual Studio 2022 or VS Code with C# extension

### Build
```bash
# Build the project
dotnet build

# Run tests
dotnet test

# Run the application (if applicable)
dotnet run
```

## 📦 Dependencies

Dependencies are automatically detected based on project requirements and include:
- Test framework packages ({test_framework})
- Scenario-specific packages (e.g., web frameworks, database drivers, etc.)
- CosmosDB packages (if detected in requirements)

All package versions are centrally managed and automatically updated.

## 📝 Generated Files

The LLM will generate all implementation files based on the functional requirements.

No dummy or placeholder test files are automatically created.
The LLM should generate real, working test implementations.

---
*Generated on {self._get_current_date()} for {product_name}*
"""
    
    def _format_scenarios_list(self, scenarios: List[str]) -> str:
        """Format scenarios as numbered list"""
        return '\n'.join(f'{i+1}. **{scenario}**' for i, scenario in enumerate(scenarios))
    
    def _get_current_date(self) -> str:
        """Get current date for documentation"""
        return datetime.now().strftime("%Y-%m-%d")
    
    def _sanitize_csharp_identifier(self, name: str) -> str:
        """Sanitize name to be valid C# identifier"""
        # Remove special characters and replace with valid characters
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '', name.replace(' ', '').replace('-', ''))
        
        # Ensure it starts with a letter or underscore
        if sanitized and not (sanitized[0].isalpha() or sanitized[0] == '_'):
            sanitized = 'App' + sanitized
        
        # Return valid identifier or default
        return sanitized if sanitized else 'CSharpApp'
